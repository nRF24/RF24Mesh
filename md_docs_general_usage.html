<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RF24Mesh - Automated Networking for nrf24L01 radios: General Usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RF24Mesh - Automated Networking for nrf24L01 radios<span id="projectnumber">&#160;v2.0.0</span>
   </div>
   <div id="projectbrief">TMRh20 2020 - A user friendly mesh overlay for sensor neworks using RF24Network</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">General Usage </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1">Network Design Options</a></li>
<li class="level1"><a href="#autotoc_md2">Network Management</a><ul><li class="level2"><a href="#autotoc_md3">Raspberry Pi/Linux</a></li>
<li class="level2"><a href="#autotoc_md4">Arduino/AVR</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md5">Mesh Communication</a></li>
<li class="level1"><a href="#autotoc_md6">Tricks of Trade</a></li>
<li class="level1"><a href="#autotoc_md7">RF24Network</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Network Design Options</h1>
<ol type="1">
<li><p class="startli"><b>Static Network</b> (No Mesh)</p>
<p class="startli">RF24Network can be configured manually, with a static design. RF24Mesh is not used at all. See <a href="http://nRF24.github.io/RF24Network/md_docs_addressing.html">Network addressing</a></p>
</li>
<li><p class="startli"><b>Static Network w/Dynamic Assignment</b></p>
<p class="startli">RF24Mesh is only used to acquire an address on startup. Nodes are generally expected to remain stationary. Changes to the network would be addressed manually, by adding, removing, or resetting nodes. Users can choose to use RF24Network functions directly, or use RF24Mesh.</p>
</li>
<li><p class="startli"><b>Dynamic Network &amp; Assignment</b></p>
<p class="startli">Nodes join the mesh automatically and re-attach as required. This is the default and how the examples work.</p>
</li>
<li><p class="startli"><b>Hybrid Network</b></p>
<p class="startli">Utilizes a combination of static &amp; dynamic nodes. Requires initial planning and deployment, but can result in a more stable network, easing the use of sleeping nodes.</p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md2"></a>
Network Management</h1>
<p>RF24Network addresses can be viewed as MAC addresses, and RF24Mesh nodeIDs viewed as static IP addresses. When joining or re-attaching to the network, nodes will request a RF24Network address, and are identified via nodeID.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Raspberry Pi/Linux</h2>
<p>On Linux devices, the RF24Gateway will save address assignments to file (dhcplist.txt) so they will be restored, even if the gateway is restarted. To force network re-convergence, delete the dhcplist.txt file and restart the gateway. If nodes are configured to verify their connection at a set interval, they will come back online in time.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Arduino/AVR</h2>
<p>On all other devices, the address list is not saved. To force network re-convergence, restart the gateway. If nodes are configured to verify their connection at a set interval, they will come back online in time.</p>
<p>If a node/nodeID is removed from the network permanently, the address should be released prior to removal. If it is not, the assigned RF24Network address can be written to 0 in the RF24Mesh address list.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Mesh Communication</h1>
<p>RF24Mesh nodeIDs are unique identifiers, while RF24Network addresses change dynamically within a statically defined structure. Due to this structure, it is simple for any node to communicate with the master node, since the RF24Network address is always known (00). Conversely, the master node maintains a list of every node on the network, so address 'lookups' return immediately.</p>
<p>Communication from node-to-node requires address queries to be sent to the master node, since individual nodes may change RF24Network &amp; radio address at any time. Due to the extra data transmissions, node-to-node communication is less efficient.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Tricks of Trade</h1>
<p>One thing to keep in mind is the dynamic nature of RF24Mesh, and the need to verify connectivity to the network. For nodes that are constantly transmitting, (every few seconds at most) it is suitable to check the connection, and/or renew the address when connectivity fails. Since data is not saved by the master node, if the master node goes down, all child nodes must renew their address. In this case, as long as the master node is down for a few seconds, the nodes will all begin requesting an address.</p>
<p>Nodes that are not actively transmitting, should be configured to test their connection at predefined intervals, to allow them to reconnect as necessary.</p>
<p>In the case of sleeping nodes, or nodes that will only be online temporarily, it is generally suitable to release the address prior to going offline, and requesting an address upon waking. Keep in mind, address requests can generally take anywhere from 10 - 15ms, up to few seconds in most cases.</p>
<p>One of the recently introduced features is the ability to transmit payloads without the network returning a network-ack response. If solely using this method of transmission, the node should also be configured to verify its connection via <code><a class="el" href="classESBMesh.html#a3fd97b30a03d51b88825e2c5b460067a">RF24Mesh::checkConnection()</a></code> periodically, to ensure connectivity.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
RF24Network</h1>
<p>Beyond requesting and releasing addresses, usage is outlined in the RF24Mesh class documentation, and further information regarding RF24Network is available at <a href="http://nRF24.github.io/RF24Network">RF24Network documentation</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 22 2023 11:45:26 for RF24Mesh - Automated Networking for nrf24L01 radios by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
